// Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
package com.yahoo.vespa.hosted.node.maintenance;

import com.yahoo.vespa.hosted.dockerapi.ProcessResult;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Takes in a compressed (lz4) or uncompressed core dump and collects relevant metadata.
 *
 * @author freva
 */
public class CoreCollector {
    private static final String GDB_PATH = "/home/y/bin64/gdb";
    private static final Pattern CORE_GENERATOR_PATH_PATTERN = Pattern.compile("^Core was generated by `(?<path>.*?)'.$");
    private static final Pattern EXECFN_PATH_PATTERN = Pattern.compile("^.* execfn: '(?<path>.*?)'");
    private static final Pattern FROM_PATH_PATTERN = Pattern.compile("^.* from '(?<path>.*?)'");
    private static final Pattern TOTAL_MEMORY_PATTERN = Pattern.compile("^MemTotal:\\s*(?<totalMem>\\d+) kB$", Pattern.MULTILINE);


    private static Path readBinPathFallback(Path coredumpPath) throws IOException, InterruptedException {
        String command = GDB_PATH + " -n -batch -core " + coredumpPath + " | grep \'^Core was generated by\'";
        ProcessResult result = Maintainer.exec("sh", "-c", "\"" + command + "\"");

        Matcher matcher = CORE_GENERATOR_PATH_PATTERN.matcher(result.getOutput());
        if (! matcher.find()) {
            throw new RuntimeException("Failed to extract binary path from " + result);
        }
        return Paths.get(matcher.group("path").split(" ")[0]);
    }

    private static Path readBinPath(Path coredumpPath) throws IOException, InterruptedException {
        ProcessResult result = Maintainer.exec("file", coredumpPath.toString());

        Matcher execfnMatcher = EXECFN_PATH_PATTERN.matcher(result.getOutput());
        if (execfnMatcher.find()) {
            return Paths.get(execfnMatcher.group("path").split(" ")[0]);
        }

        Matcher fromMatcher = FROM_PATH_PATTERN.matcher(result.getOutput());
        if (fromMatcher.find()) {
            return Paths.get(fromMatcher.group("path").split(" ")[0]);
        }

        return readBinPathFallback(coredumpPath);
    }

    private static List<String> readBacktrace(Path coredumpPath, Path binPath, boolean allThreads) throws IOException, InterruptedException {
        ProcessResult result = Maintainer.exec(GDB_PATH, "-n", "-ex", (allThreads ? "thread apply all bt" : "bt"),
                "-batch", binPath.toString(), coredumpPath.toString());
        return Arrays.asList(result.getOutput().split("\n"));
    }

    public Map<String, Object> collect(Path coredumpPath) throws IOException, InterruptedException {
        coredumpPath = decompressCoredump(coredumpPath);
        Path binPath = readBinPath(coredumpPath);

        Map<String, Object> data = new LinkedHashMap<>();
        data.put("bin_path", binPath.toString());
        data.put("backtrace", readBacktrace(coredumpPath, binPath, false));
        data.put("backtrace_all_threads", readBacktrace(coredumpPath, binPath, true));

        deleteDecompressedCoredump(coredumpPath);
        return data;
    }


    private static Path decompressCoredump(Path coredumpPath) throws IOException, InterruptedException {
        if (! coredumpPath.toString().endsWith(".lz4")) return coredumpPath;

        if (! diskSpaceAvailable(coredumpPath)) {
            throw new RuntimeException("Not decompressing " + coredumpPath + " due to not enough disk space available");
        }

        Path decompressedPath = Paths.get(coredumpPath.toString().replaceFirst("\\.lz4$", ""));

        ProcessResult result = Maintainer.exec("/home/y/bin64/lz4", "-d", coredumpPath.toString(), decompressedPath.toString());
        if (! result.isSuccess()) {
            throw new RuntimeException("Failed to decompress file " + coredumpPath + ": " + result);
        }
        return decompressedPath;
    }

    /**
     * Delete the coredump unless:
     * - The file is compressed
     * - There is no compressed file (i.e. it was not decompressed in the first place)
     */
    private static void deleteDecompressedCoredump(Path coredumpPath) throws IOException {
        if (! coredumpPath.toString().endsWith(".lz4") && Paths.get(coredumpPath.toString() + ".lz4").toFile().exists()) {
            Files.delete(coredumpPath);
        }
    }

    private static boolean diskSpaceAvailable(Path path) throws IOException {
        String memInfo = new String(Files.readAllBytes(Paths.get("/proc/meminfo")));

        Matcher matcher = TOTAL_MEMORY_PATTERN.matcher(memInfo);
        if (!matcher.find()) return false;
        int totalMem = Integer.valueOf(matcher.group("totalMem"));

        return path.toFile().getFreeSpace() > totalMem;
    }
}
