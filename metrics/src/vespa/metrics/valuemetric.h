// Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
/**
 * @class metrics::ValueMetric
 * @ingroup metrics
 *
 * @brief Creates a metric measuring any value.
 *
 * A value metric have the following properties:
 *   - Logs the average as a value event. (It is not strictly increasing)
 *   - When summing average metrics together, the sum becomes the average of
 *     all values added to both.
 */

#pragma once

#include <vespa/vespalib/util/sync.h>
#include <vespa/vespalib/util/exceptions.h>
#include <sstream>
#include <type_traits>
#include <cmath>
#include <vespa/metrics/metric.h>
#include <vespa/metrics/metricvalueset.h>
#include <vespa/vespalib/util/jsonstream.h>
#include <vespa/vespalib/util/stringfmt.h>
#include <atomic>

namespace metrics {

struct AbstractValueMetric : public Metric {
    virtual bool visit(MetricVisitor& visitor,
                       bool tagAsAutoGenerated = false) const
    {
        return visitor.visitValueMetric(*this, tagAsAutoGenerated);
    }
    virtual MetricValueClass::UP getValues() const = 0;
    virtual bool inUse(const MetricValueClass& v) const = 0;
    virtual bool summedAverage() const = 0;

protected:
    AbstractValueMetric(const String& name, const String& tags,
                        const String& description, MetricSet* owner)
        : Metric(name, tags, description, owner) {}

    AbstractValueMetric(const String& name, Tags dimensions,
                        const String& description, MetricSet* owner)
        : Metric(name, std::move(dimensions), description, owner) {}

    AbstractValueMetric(const AbstractValueMetric& other, MetricSet* owner)
        : Metric(other, owner) {}

    void logWarning(const char* msg) const;
    void logNonFiniteValueWarning() const;
    void sendLogEvent(Metric::String name, double value) const;
};

template<typename AvgVal, typename TotVal, bool SumOnAdd>
class ValueMetric
          : public AbstractValueMetric
{
    typedef Metric::String String; // Redefine so template finds it easy

    struct Values : MetricValueClass {
        uint32_t _count;
        AvgVal _min, _max, _last;
        TotVal _total;

        struct AtomicImpl {
            std::atomic<uint32_t> _count {0};
            std::atomic<AvgVal> _min {std::numeric_limits<AvgVal>::max()};
            std::atomic<AvgVal> _max {std::numeric_limits<AvgVal>::min()};
            std::atomic<AvgVal> _last {0};
            std::atomic<TotVal> _total {0};
        };

        Values()
            : _count(0),
              _min(std::numeric_limits<AvgVal>::max()),
              _max(std::numeric_limits<AvgVal>::min()),
              _last(0),
              _total(0)
        {
                // numeric_limits min() returns smallest positive number
                // for signed floating point types. Haven't found a way to
                // get minimum negative value, so using -1 * positive for those.
            if (std::numeric_limits<AvgVal>::is_signed
                && !std::numeric_limits<AvgVal>::is_integer)
            {
                _max = -1 * std::numeric_limits<AvgVal>::max();
            }
        }

        void relaxedStoreInto(AtomicImpl& target) const noexcept {
            target._count.store(_count, std::memory_order_relaxed);
            target._min.store(_min, std::memory_order_relaxed);
            target._max.store(_max, std::memory_order_relaxed);
            target._last.store(_last, std::memory_order_relaxed);
            target._total.store(_total, std::memory_order_relaxed);
        }

        void relaxedLoadFrom(const AtomicImpl& source) noexcept {
            _count = source._count.load(std::memory_order_relaxed);
            _min = source._min.load(std::memory_order_relaxed);
            _max = source._max.load(std::memory_order_relaxed);
            _last = source._last.load(std::memory_order_relaxed);
            _total = source._total.load(std::memory_order_relaxed);
        }

        template<typename T>
        T getValue(const stringref & id) const {
            if (id == "last") return static_cast<T>(_last);
            if (id == "count") return static_cast<T>(_count);
            if (id == "total") return static_cast<T>(_total);
            if (id == "min") return static_cast<T>(_count > 0 ? _min : 0);
            if (id == "max") return static_cast<T>( _count > 0 ? _max : 0);
            throw vespalib::IllegalArgumentException(
                    "No value " + vespalib::string(id) + " in value metric.", VESPA_STRLOC);
        }

        double getDoubleValue(const stringref & id) const {
            return getValue<double>(id);
        }
        uint64_t getLongValue(const stringref & id) const {
            return getValue<uint64_t>(id);
        }
        void output(const std::string& id, std::ostream& out) const {
            if (id == "last") { out << _last; return; }
            if (id == "count") { out << _count; return; }
            if (id == "total") { out << _total; return; }
            if (id == "min") { out << (_count > 0 ? _min : 0); return; }
            if (id == "max") { out << (_count > 0 ? _max : 0); return; }
            throw vespalib::IllegalArgumentException(
                    "No value " + id + " in value metric.", VESPA_STRLOC);
        }
        void output(const std::string& id, vespalib::JsonStream& stream) const {
            if (id == "last") { stream << _last; return; }
            if (id == "count") { stream << _count; return; }
            if (id == "total") { stream << _total; return; }
            if (id == "min") { stream << (_count > 0 ? _min : 0); return; }
            if (id == "max") { stream << (_count > 0 ? _max : 0); return; }
            throw vespalib::IllegalArgumentException(
                    "No value " + id + " in value metric.", VESPA_STRLOC);
        }
        friend std::ostream & operator << (std::ostream & os, const Values & v) {
            os << "count=" << v._count;
            os << ", total=" << v._total;
            return os;
        }
    };

    MetricValueSet<Values> _values;

    enum Flag { SUMMED_AVERAGE = 2, UNSET_ON_ZERO_VALUE = 4, LOG_IF_UNSET = 8 };

    virtual bool summedAverage() const
        { return _values.hasFlag(SUMMED_AVERAGE); }
    bool unsetOnZeroValue() const
        { return _values.hasFlag(UNSET_ON_ZERO_VALUE); }
    bool logIfUnset() const { return _values.hasFlag(LOG_IF_UNSET); }

    void add(const Values& values, bool sumOnAdd);
    void dec(const Values& values);

    void addValueWithCount(AvgVal avg, TotVal tot, uint32_t count);

    // Finite number (not infinity/NaN) check using type trait tag dispatch.
    // 2nd param is instance of std::true_type iff AvgVal is floating point.
    bool checkFinite(AvgVal v, std::true_type) {
        if (!std::isfinite(v)) {
            logNonFiniteValueWarning();
            return false;
        }
        return true;
    }
    bool checkFinite(AvgVal, std::false_type) { return true; }

public:
    ValueMetric(const String& name, const String& tags,
                const String& description, MetricSet* owner = 0);

    ValueMetric(const ValueMetric<AvgVal, TotVal, SumOnAdd>&,
                CopyType, MetricSet* owner);

    ValueMetric(const String& name, Tags dimensions,
                const String& description, MetricSet* owner = 0);

    virtual MetricValueClass::UP getValues() const
        { return MetricValueClass::UP(new Values(_values.getValues())); }

    void unsetOnZeroValue() { _values.setFlag(UNSET_ON_ZERO_VALUE); }
    void logOnlyIfSet() { _values.removeFlag(LOG_IF_UNSET); }

    virtual ValueMetric<AvgVal, TotVal, SumOnAdd>* clone(
            std::vector<Metric::LP>&, CopyType type, MetricSet* owner,
            bool /*includeUnused*/) const
        { return new ValueMetric<AvgVal,TotVal,SumOnAdd>(*this, type, owner); }

    ValueMetric & operator+=(const ValueMetric &);

    friend ValueMetric operator+(const ValueMetric & a, const ValueMetric & b) {
        ValueMetric t(a); t += b; return t;
    }

    void addAvgValueWithCount(AvgVal avg, uint32_t count)
    { if (count) { addValueWithCount(avg, avg * count, count); } }
    void addTotalValueWithCount(TotVal tot, uint32_t count)
    { if (count) { addValueWithCount(tot / count, tot, count); } }
    void addValueBatch(AvgVal avg, uint32_t count) {
        addAvgValueWithCount(avg, count);
    }
    virtual void addValue(AvgVal avg) { addAvgValueWithCount(avg, 1); }
    virtual void set(AvgVal avg) { addValue(avg); }
    virtual void inc(AvgVal val = 1);
    virtual void dec(AvgVal val = 1);

    double getAverage() const;
    AvgVal getMinimum() const { return _values.getValues()._min; }
    AvgVal getMaximum() const { return _values.getValues()._max; }
    AvgVal getCount() const { return _values.getValues()._count; }
    AvgVal getLast() const { return _values.getValues()._last; }

    void reset() { _values.reset(); }

    virtual bool logEvent(const String& fullName) const;

    virtual void print(std::ostream&, bool verbose,
                       const std::string& indent, uint64_t secondsPassed) const;

    virtual int64_t getLongValue(const stringref & id) const;
    virtual double getDoubleValue(const stringref & id) const;


    virtual bool inUse(const MetricValueClass& v) const {
        const Values& values(static_cast<const Values&>(v));
        return (values._total != 0
                || (values._count != 0 && !unsetOnZeroValue()));
    }
    virtual bool used() const {
        return inUse(_values.getValues());
    }

    virtual void addMemoryUsage(MemoryConsumption&) const;

    virtual void printDebug(std::ostream&, const std::string& indent) const;

    virtual void addToPart(Metric&) const;
    virtual void addToSnapshot(Metric&, std::vector<Metric::LP>&) const;
};

typedef ValueMetric<double, double, true> DoubleValueMetric;
typedef ValueMetric<double, double, false> DoubleAverageMetric;
typedef ValueMetric<int64_t, int64_t, true> LongValueMetric;
typedef ValueMetric<int64_t, int64_t, false> LongAverageMetric;

template<typename AvgVal, typename TotVal, bool SumOnAdd>
ValueMetric<AvgVal, TotVal, SumOnAdd>::ValueMetric(
        const String& name, const String& tags,
        const String& description, MetricSet* owner)
    : AbstractValueMetric(name, tags, description, owner),
      _values()
{
    _values.setFlag(LOG_IF_UNSET);
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
ValueMetric<AvgVal, TotVal, SumOnAdd>::ValueMetric(
        const String& name, const Tags dimensions,
        const String& description, MetricSet* owner)
    : AbstractValueMetric(name, std::move(dimensions), description, owner),
      _values()
{
    _values.setFlag(LOG_IF_UNSET);
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
ValueMetric<AvgVal, TotVal, SumOnAdd>::ValueMetric(
        const ValueMetric<AvgVal, TotVal, SumOnAdd>& other,
        CopyType copyType, MetricSet* owner)
    : AbstractValueMetric(other, owner),
      _values(other._values, copyType == CLONE ? other._values.size() : 1)
{
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void ValueMetric<AvgVal, TotVal, SumOnAdd>::inc(AvgVal incVal)
{
    if (!checkFinite(incVal, std::is_floating_point<AvgVal>())) {
        return;
    }
    Values values;
    do {
        values = _values.getValues();
        AvgVal val = values._last + incVal;
        ++values._count;
        values._total += val;
        if (val < values._min) values._min = val;
        if (val > values._max) values._max = val;
        values._last = val;
    } while (!_values.setValues(values));
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void ValueMetric<AvgVal, TotVal, SumOnAdd>::dec(AvgVal decVal)
{
    if (!checkFinite(decVal, std::is_floating_point<AvgVal>())) {
        return;
    }
    Values values;
    do {
        values = _values.getValues();
        AvgVal val = values._last - decVal;
        ++values._count;
        values._total += val;
        if (val < values._min) values._min = val;
        if (val > values._max) values._max = val;
        values._last = val;
    } while (!_values.setValues(values));
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void
ValueMetric<AvgVal, TotVal, SumOnAdd>::addToSnapshot(
        Metric& other, std::vector<Metric::LP>&) const
{
    ValueMetric<AvgVal, TotVal, SumOnAdd>& o(
            reinterpret_cast<ValueMetric<AvgVal, TotVal, SumOnAdd>&>(other));
    if (_values.getValues()._count == 0) return; // Don't add if not set
    o.add(_values.getValues(), false);
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void
ValueMetric<AvgVal, TotVal, SumOnAdd>::addToPart(Metric& other) const
{
    ValueMetric<AvgVal, TotVal, SumOnAdd>& o(
            reinterpret_cast<ValueMetric<AvgVal, TotVal, SumOnAdd>&>(
                other));
    o.add(_values.getValues(), SumOnAdd);
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void
ValueMetric<AvgVal, TotVal, SumOnAdd>::add(const Values& values2, bool sumOnAdd)
{
    bool overflow;
    Values values;
    do {
        values = _values.getValues();
        overflow = values._count > values._count + values2._count
                || (values2._total >= 0
                    ? values._total > values._total + values2._total
                    : values._total < values._total + values2._total);
        if (values._count == 0) {
            values = values2;
        } else if (values2._count == 0) {
            // Do nothing
        } else if (sumOnAdd) {
            double totalAverage
                    = static_cast<double>(values._total) / values._count
                    + static_cast<double>(values2._total) / values2._count;
            values._count += values2._count;
            values._total = static_cast<TotVal>(totalAverage * values._count);
            values._last += values2._last;
            _values.setFlag(SUMMED_AVERAGE);
        } else {
            values._count += values2._count;
            values._total += values2._total;
            values._last = values2._last;
        }
        if (values._min > values2._min) values._min = values2._min;
        if (values._max < values2._max) values._max = values2._max;
    } while (!_values.setValues(values));
    if (overflow) {
        std::ostringstream ost;
        ost << "ValueMetric " << getPath() << " overflowed. Resetting it. Old value = (";
        ost << values << "), Incoming = (" << values2 << ")";
        logWarning(ost.str().c_str());
        _values.reset();
    }
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void
ValueMetric<AvgVal, TotVal, SumOnAdd>::dec(const Values& values2)
{
    bool underflow;
    Values values;
    do {
        values = _values.getValues();
        underflow = values._count < values._count - values2._count
                || values._total < values._total - values2._total;
        values._count -= values2._count;
        values._total -= values2._total;
    } while (!_values.setValues(values));
    if (underflow) {
        _values.reset();
        std::ostringstream ost;
        ost << "ValueMetric " << getPath() << " underflowed. Resetting it.";
        logWarning(ost.str().c_str());
    }
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void ValueMetric<AvgVal, TotVal, SumOnAdd>::addValueWithCount(
        AvgVal avg, TotVal tot, uint32_t count)
{
    if (!checkFinite(avg, std::is_floating_point<AvgVal>())) {
        return;
    }
    Values values;
    do {
        values = _values.getValues();
        values._count += count;
        values._total += tot;
        if (avg < values._min) values._min = avg;
        if (avg > values._max) values._max = avg;
        values._last = avg;
    } while (!_values.setValues(values));
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
ValueMetric<AvgVal, TotVal, SumOnAdd>&
ValueMetric<AvgVal, TotVal, SumOnAdd>::operator+=(
        const ValueMetric<AvgVal, TotVal, SumOnAdd>& other)
{
    add(other._values.getValues(), SumOnAdd);
    return *this;
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
double
ValueMetric<AvgVal, TotVal, SumOnAdd>::getAverage() const
{
    Values values(_values.getValues());
    if (values._count == 0) return 0;
    return static_cast<double>(values._total) / values._count;
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
bool
ValueMetric<AvgVal, TotVal, SumOnAdd>::logEvent(const String& fullName) const
{
    Values values(_values.getValues());
    if (!logIfUnset() && !inUse(values)) return false;
    sendLogEvent(fullName, SumOnAdd
            ? static_cast<double>(values._last)
            : static_cast<double>(values._total) / values._count);
    return true;
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void
ValueMetric<AvgVal, TotVal, SumOnAdd>::print(
        std::ostream& out, bool verbose, const std::string& indent,
        uint64_t secondsPassed) const
{
    (void) indent;
    (void) secondsPassed;
    Values values(_values.getValues());
    if (!inUse(values) && !verbose) return;
    out << this->_name << " average=" << (values._count == 0
            ? 0 : static_cast<double>(values._total) / values._count)
        << " last=" << values._last;
    if (!summedAverage()) {
        if (values._count > 0) {
            out << " min=" << values._min << " max=" << values._max;
        }
        out << " count=" << values._count << " total=" << values._total;
    }
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
int64_t
ValueMetric<AvgVal, TotVal, SumOnAdd>::getLongValue(const stringref & id) const
{
    Values values(_values.getValues());
    if (id == "last" || (SumOnAdd && id == "value"))
        return static_cast<int64_t>(values._last);
    if (id == "average" || (!SumOnAdd && id == "value"))
        return static_cast<int64_t>(getAverage());
    if (id == "count") return static_cast<int64_t>(values._count);
    if (id == "total") return static_cast<int64_t>(values._total);
    if (id == "min") return static_cast<int64_t>(
            values._count > 0 ? values._min : 0);
    if (id == "max") return static_cast<int64_t>(
            values._count > 0 ? values._max : 0);
    throw vespalib::IllegalArgumentException(
            "No value " + id + " in average metric.", VESPA_STRLOC);
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
double
ValueMetric<AvgVal, TotVal, SumOnAdd>::getDoubleValue(const stringref & id) const
{
    Values values(_values.getValues());
    if (id == "last" || (SumOnAdd && id == "value"))
        return static_cast<double>(values._last);
    if (id == "average" || (!SumOnAdd && id == "value"))
        return getAverage();
    if (id == "count") return static_cast<double>(values._count);
    if (id == "total") return static_cast<double>(values._total);
    if (id == "min") return static_cast<double>(
            values._count > 0 ? values._min : 0);
    if (id == "max") return static_cast<double>(
            values._count > 0 ? values._max : 0);
    throw vespalib::IllegalArgumentException(
            "No value " + vespalib::string(id) + " in average metric.", VESPA_STRLOC);
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void
ValueMetric<AvgVal, TotVal, SumOnAdd>::addMemoryUsage(
        MemoryConsumption& mc) const
{
    ++mc._valueMetricCount;
    mc._valueMetricValues += _values.getMemoryUsageAllocatedInternally();
    mc._valueMetricMeta += sizeof(ValueMetric<AvgVal, TotVal, SumOnAdd>)
                         - sizeof(Metric);
    Metric::addMemoryUsage(mc);
}

template<typename AvgVal, typename TotVal, bool SumOnAdd>
void
ValueMetric<AvgVal, TotVal, SumOnAdd>::printDebug(
        std::ostream& out, const std::string& indent) const
{
    Values values(_values.getValues());
    out << "value=" << values._last << " ";
    Metric::printDebug(out, indent);
}

} // metrics

