// Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
/**
 * \class CountMetric
 * \ingroup metrics
 *
 * \brief Metric representing a count.
 *
 * A counter metric have the following properties:
 *   - It can never decrease, only increase.
 *   - Logs its value as a count event.
 *   - When summing counts, the counts are added together.
 */

#pragma once

#include <sstream>
#include <vespa/metrics/metric.h>
#include <vespa/metrics/metricvalueset.h>
#include <vespa/vespalib/util/jsonstream.h>
#include <atomic>

namespace metrics {

struct AbstractCountMetric : public Metric {
    virtual bool visit(MetricVisitor& visitor,
                       bool tagAsAutoGenerated = false) const
    {
        return visitor.visitCountMetric(*this, tagAsAutoGenerated);
    }
    virtual MetricValueClass::UP getValues() const = 0;
    virtual bool sumOnAdd() const = 0;
    virtual bool inUse(const MetricValueClass& v) const = 0;

protected:
    AbstractCountMetric(const String& name, const String& tags,
                        const String& description, MetricSet* owner = 0)
        : Metric(name, tags, description, owner)
    {
    }

    AbstractCountMetric(const String& name, Tags dimensions,
                        const String& description, MetricSet* owner = 0)
        : Metric(name, std::move(dimensions), description, owner)
    {
    }

    AbstractCountMetric(const AbstractCountMetric& other, MetricSet* owner)
        : Metric(other, owner)
    {
    }

    void logWarning(const char* msg) const;
    void sendLogCountEvent(Metric::String name, uint64_t value) const;
};

template<typename T, bool SumOnAdd>
class CountMetric : public AbstractCountMetric
{
    struct Values : public MetricValueClass {
        T _value;

        struct AtomicImpl {
            std::atomic<T> _value {0};
        };

        void relaxedStoreInto(AtomicImpl& target) const noexcept {
            target._value.store(_value, std::memory_order_relaxed);
        }

        void relaxedLoadFrom(const AtomicImpl& source) noexcept {
            _value = source._value.load(std::memory_order_relaxed);
        }

        Values() : _value(0) {}

        std::string toString() const {
            std::ostringstream ost;
            ost << _value;
            return ost.str();
        }
        double getDoubleValue(const stringref &) const
            { return static_cast<double>(_value); }
        uint64_t getLongValue(const stringref &) const
            { return static_cast<uint64_t>(_value); }
        void output(const std::string&, std::ostream& out) const
            { out << _value; }
        void output(const std::string&, vespalib::JsonStream& stream) const
            { stream << _value; }
        bool inUse() const { return (_value != 0); }
    };
    MetricValueSet<Values> _values;

    enum Flag { LOG_IF_UNSET = 2 };

    bool logIfUnset() const { return _values.hasFlag(LOG_IF_UNSET); }

public:
    CountMetric(const String& name, const String& tags,
                const String& description, MetricSet* owner = 0);

    CountMetric(const String& name, Tags dimensions,
                const String& description, MetricSet* owner = 0);

    CountMetric(const CountMetric<T, SumOnAdd>& other,
                CopyType, MetricSet* owner);

    virtual MetricValueClass::UP getValues() const
        { return MetricValueClass::UP(new Values(_values.getValues())); }
    void logOnlyIfSet() { _values.removeFlag(LOG_IF_UNSET); }

    void set(T value);
    void inc(T value = 1);
    void dec(T value = 1);
    CountMetric & operator++() { inc(); return *this; }
    CountMetric & operator--() { dec(); return *this; }

    CountMetric operator++(int) { CountMetric tmp(*this); inc(); return tmp; }
    CountMetric operator--(int) { CountMetric tmp(*this); inc(); return tmp; }

    CountMetric & operator+=(const CountMetric &);
    CountMetric & operator-=(const CountMetric &);
    friend CountMetric operator+(const CountMetric & a, const CountMetric & b) {
        CountMetric t(a); t += b; return t;
    }
    friend CountMetric operator-(const CountMetric & a, const CountMetric & b) {
        CountMetric t(a); t -= b; return t;
    }

    virtual CountMetric * clone(
            std::vector<Metric::LP>&, CopyType type, MetricSet* owner,
            bool /*includeUnused*/) const
        { return new CountMetric<T, SumOnAdd>(*this, type, owner); }

    T getValue() const { return _values.getValues()._value; }

    void reset() {
        _values.reset();
    }

    virtual bool logFromTotalMetrics() const { return true; }
    virtual bool logEvent(const String& fullName) const;

    virtual void print(std::ostream&, bool verbose,
                       const std::string& indent, uint64_t secondsPassed) const;

    // Only one metric in valuemetric, so return it on any id.
    virtual int64_t getLongValue(const stringref & id) const
        { (void) id; return static_cast<int64_t>(getValue()); }
    virtual double getDoubleValue(const stringref & id) const
        { (void) id; return static_cast<double>(getValue()); }

    virtual bool inUse(const MetricValueClass& v) const
        { return static_cast<const Values&>(v).inUse(); }
    virtual bool used() const { return _values.getValues().inUse(); }
    virtual bool sumOnAdd() const { return SumOnAdd; }

    virtual void addMemoryUsage(MemoryConsumption&) const;

    virtual void printDebug(std::ostream&, const std::string& indent) const;

    virtual void addToPart(Metric&) const;
    virtual void addToSnapshot(Metric&, std::vector<Metric::LP>&) const;

};

typedef CountMetric<uint64_t, true> LongCountMetric;

template <typename T, bool SumOnAdd>
CountMetric<T, SumOnAdd>::CountMetric(const String& name, const String& tags,
                                      const String& desc, MetricSet* owner)
    : AbstractCountMetric(name, tags, desc, owner),
      _values()
{
    _values.setFlag(LOG_IF_UNSET);
}

template <typename T, bool SumOnAdd>
CountMetric<T, SumOnAdd>::CountMetric(const String& name, Tags dimensions,
                                      const String& desc, MetricSet* owner)
    : AbstractCountMetric(name, std::move(dimensions), desc, owner),
      _values()
{
    _values.setFlag(LOG_IF_UNSET);
}

template <typename T, bool SumOnAdd>
CountMetric<T, SumOnAdd>::CountMetric(const CountMetric<T, SumOnAdd>& other,
                                      CopyType copyType, MetricSet* owner)
    : AbstractCountMetric(other, owner),
      _values(other._values, copyType == CLONE ? other._values.size() : 1)
{
}

template <typename T, bool SumOnAdd>
CountMetric<T, SumOnAdd>&
CountMetric<T, SumOnAdd>::operator+=(const CountMetric<T, SumOnAdd>& other)
{
    T otherValues(other.getValue());
    bool overflow;
    Values values;
    do {
        values = _values.getValues();
        overflow = (values._value + otherValues < values._value);
        values._value += otherValues;
    } while (!_values.setValues(values));
    if (overflow) {
        _values.reset();
        std::ostringstream ost;
        ost << "Overflow in metric " << getPath() << " op +=. Resetting it.";
        logWarning(ost.str().c_str());
    }
    return *this;
}

template <typename T, bool SumOnAdd>
CountMetric<T, SumOnAdd>&
CountMetric<T, SumOnAdd>::operator-=(const CountMetric<T, SumOnAdd>& other)
{
    T otherValues(other.getValue());
    bool underflow;
    Values values;
    do {
        values = _values.getValues();
        underflow = (values._value - otherValues > values._value);
        values._value -= otherValues;
    } while (!_values.setValues(values));
    if (underflow) {
        _values.reset();
        std::ostringstream ost;
        ost << "Underflow in metric " << getPath() << " op -=. Resetting it.";
        logWarning(ost.str().c_str());
    }
    return *this;
}

template <typename T, bool SumOnAdd>
void
CountMetric<T, SumOnAdd>::set(T value)
{
    Values values;
    values._value = value;
    while (!_values.setValues(values)) {}
}

template <typename T, bool SumOnAdd>
void
CountMetric<T, SumOnAdd>::inc(T value)
{
    bool overflow;
    Values values;
    do {
        values = _values.getValues();
        overflow = (values._value + value < values._value);
        values._value += value;
    } while (!_values.setValues(values));
    if (overflow) {
        _values.reset();
        std::ostringstream ost;
        ost << "Overflow in metric " << getPath() << ". Resetting it.";
        logWarning(ost.str().c_str());
    }
}

template <typename T, bool SumOnAdd>
void
CountMetric<T, SumOnAdd>::dec(T value)
{
    bool underflow;
    Values values;
    do {
        values = _values.getValues();
        underflow = (values._value - value > values._value);
        values._value -= value;
    } while (!_values.setValues(values));
    if (underflow) {
        _values.reset();
        std::ostringstream ost;
        ost << "Underflow in metric " << getPath() << ". Resetting it.";
        logWarning(ost.str().c_str());
    }
}

template <typename T, bool SumOnAdd>
void
CountMetric<T, SumOnAdd>::addToSnapshot(
        Metric& other, std::vector<Metric::LP>&) const
{
    CountMetric<T, SumOnAdd>& o(
            reinterpret_cast<CountMetric<T, SumOnAdd>&>(other));
    o.inc(_values.getValues()._value);
}

template <typename T, bool SumOnAdd>
void
CountMetric<T, SumOnAdd>::addToPart(Metric& other) const
{
    CountMetric<T, SumOnAdd>& o(
            reinterpret_cast<CountMetric<T, SumOnAdd>&>(other));
    if (SumOnAdd) {
        o.inc(_values.getValues()._value);
    } else {
        o.set((_values.getValues()._value + o._values.getValues()._value) / 2);
    }
}

template <typename T, bool SumOnAdd>
bool
CountMetric<T, SumOnAdd>::logEvent(const String& fullName) const
{
    Values values(_values.getValues());
    if (!logIfUnset() && values._value == 0) return false;
    sendLogCountEvent(
            fullName, static_cast<uint64_t>(values._value));
    return true;
}

template <typename T, bool SumOnAdd>
void
CountMetric<T, SumOnAdd>::print(std::ostream& out, bool verbose,
                                const std::string& indent,
                                uint64_t secondsPassed) const
{
    (void) indent;
    Values values(_values.getValues());
    if (values._value == 0 && !verbose) return;
    out << this->_name << (SumOnAdd ? " count=" : " value=") << values._value;
    if (SumOnAdd) {
        if (secondsPassed != 0) {
            double avgDiff = values._value / ((double) secondsPassed);
            out << " average_change_per_second=" << avgDiff;
        }
    }
}

template <typename T, bool SumOnAdd>
void
CountMetric<T, SumOnAdd>::addMemoryUsage(MemoryConsumption& mc) const
{
    ++mc._countMetricCount;
    mc._countMetricValues += _values.getMemoryUsageAllocatedInternally();
    mc._countMetricMeta += sizeof(CountMetric<T, SumOnAdd>)
                         - sizeof(Metric);
    Metric::addMemoryUsage(mc);
}

template <typename T, bool SumOnAdd>
void
CountMetric<T, SumOnAdd>::printDebug(std::ostream& out,
                                     const std::string& indent) const
{
    Values values(_values.getValues());
    out << "count=" << values._value << " ";
    Metric::printDebug(out, indent);
}

} // metrics

