// Copyright 2016 Yahoo Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
/**
 * \class CountMetric
 * \ingroup metrics
 *
 * \brief Metric representing a count.
 *
 * A counter metric have the following properties:
 *   - It can never decrease, only increase.
 *   - Logs its value as a count event.
 *   - When summing counts, the counts are added together.
 */

#pragma once

#include <vespa/metrics/metric.h>
#include "countmetricvalues.h"

namespace metrics {

struct AbstractCountMetric : public Metric {
    virtual bool visit(MetricVisitor& visitor, bool tagAsAutoGenerated = false) const
    {
        return visitor.visitCountMetric(*this, tagAsAutoGenerated);
    }
    virtual MetricValueClass::UP getValues() const = 0;
    virtual bool sumOnAdd() const = 0;
    virtual bool inUse(const MetricValueClass& v) const = 0;

protected:
    AbstractCountMetric(const String& name, const String& tags,
                        const String& description, MetricSet* owner = 0)
        : Metric(name, tags, description, owner)
    {
    }

    AbstractCountMetric(const String& name, Tags dimensions,
                        const String& description, MetricSet* owner = 0)
        : Metric(name, std::move(dimensions), description, owner)
    {
    }

    AbstractCountMetric(const AbstractCountMetric& other, MetricSet* owner)
        : Metric(other, owner)
    {
    }

    void logWarning(const char* msg) const;
    void sendLogCountEvent(Metric::String name, uint64_t value) const;
};

template<typename T, bool SumOnAdd>
class CountMetric : public AbstractCountMetric
{
    using Values = CountMetricValues<T>;
    MetricValueSet<Values> _values;

    enum Flag { LOG_IF_UNSET = 2 };

    bool logIfUnset() const { return _values.hasFlag(LOG_IF_UNSET); }

public:
    CountMetric(const String& name, const String& tags,
                const String& description, MetricSet* owner = 0);

    CountMetric(const String& name, Tags dimensions,
                const String& description, MetricSet* owner = 0);

    CountMetric(const CountMetric<T, SumOnAdd>& other,
                CopyType, MetricSet* owner);

    virtual MetricValueClass::UP getValues() const
        { return MetricValueClass::UP(new Values(_values.getValues())); }
    void logOnlyIfSet() { _values.removeFlag(LOG_IF_UNSET); }

    void set(T value);
    void inc(T value = 1);
    void dec(T value = 1);
    CountMetric & operator++() { inc(); return *this; }
    CountMetric & operator--() { dec(); return *this; }

    CountMetric operator++(int) { CountMetric tmp(*this); inc(); return tmp; }
    CountMetric operator--(int) { CountMetric tmp(*this); inc(); return tmp; }

    CountMetric & operator+=(const CountMetric &);
    CountMetric & operator-=(const CountMetric &);
    friend CountMetric operator+(const CountMetric & a, const CountMetric & b) {
        CountMetric t(a); t += b; return t;
    }
    friend CountMetric operator-(const CountMetric & a, const CountMetric & b) {
        CountMetric t(a); t -= b; return t;
    }

    virtual CountMetric * clone(
            std::vector<Metric::LP>&, CopyType type, MetricSet* owner,
            bool /*includeUnused*/) const
        { return new CountMetric<T, SumOnAdd>(*this, type, owner); }

    T getValue() const { return _values.getValues()._value; }

    void reset() {
        _values.reset();
    }

    virtual bool logFromTotalMetrics() const { return true; }
    virtual bool logEvent(const String& fullName) const;

    virtual void print(std::ostream&, bool verbose,
                       const std::string& indent, uint64_t secondsPassed) const;

    // Only one metric in valuemetric, so return it on any id.
    virtual int64_t getLongValue(const stringref & id) const
        { (void) id; return static_cast<int64_t>(getValue()); }
    virtual double getDoubleValue(const stringref & id) const
        { (void) id; return static_cast<double>(getValue()); }

    virtual bool inUse(const MetricValueClass& v) const
        { return static_cast<const Values&>(v).inUse(); }
    virtual bool used() const { return _values.getValues().inUse(); }
    virtual bool sumOnAdd() const { return SumOnAdd; }

    virtual void addMemoryUsage(MemoryConsumption&) const;

    virtual void printDebug(std::ostream&, const std::string& indent) const;

    virtual void addToPart(Metric&) const;
    virtual void addToSnapshot(Metric&, std::vector<Metric::LP>&) const;
};

typedef CountMetric<uint64_t, true> LongCountMetric;

} // metrics

