package com.yahoo.searchlib.rankingexpression.integration.tensorflow;

import com.yahoo.searchlib.rankingexpression.RankingExpression;
import com.yahoo.searchlib.rankingexpression.rule.ExpressionNode;
import com.yahoo.searchlib.rankingexpression.rule.TensorFunctionNode;
import com.yahoo.tensor.TensorType;
import com.yahoo.tensor.functions.ScalarFunctions;
import com.yahoo.tensor.functions.TensorFunction;
import com.yahoo.yolean.Exceptions;
import org.tensorflow.SavedModelBundle;
import org.tensorflow.framework.GraphDef;
import org.tensorflow.framework.MetaGraphDef;
import org.tensorflow.framework.NodeDef;
import org.tensorflow.framework.SignatureDef;
import org.tensorflow.framework.TensorInfo;
import org.tensorflow.framework.TensorShapeProto;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.stream.Collectors;

/**
 * Converts a saved TensorFlow model into a ranking expression and set of constants.
 *
 * @author bratseth
 */
public class TensorFlowImporter {

    private final OperationMapper operationMapper = new OperationMapper();

    /**
     * Imports a saved TensorFlow model from a directory.
     * The model should be saved as a pbtxt file.
     * The name of the model is taken at the pbtxt file name (not including the .pbtxt ending).
     *
     * @param modelDir the directory containing the TensorFlow model files to import
     * @param constants any constant tensors imported from the TensorFlow model and referenced in the returned expressions
     * @param logger a receiver of any messages generated by the import process
     * @return the ranking expressions resulting from importing this TenorFlow model
     */
    public List<RankingExpression> importModel(String modelDir, List<NamedTensor> constants, MessageLogger logger) {
        try {
            SavedModelBundle model = SavedModelBundle.load(modelDir, "serve");
            return importGraph(MetaGraphDef.parseFrom(model.metaGraphDef()), model, constants, logger);
        }
        catch (IOException e) {
            throw new IllegalArgumentException("Could not open TensorFlow model directory '" + modelDir + "'", e);
        }

    }

    private List<RankingExpression> importGraph(MetaGraphDef graph, SavedModelBundle model,
                                                List<NamedTensor> constants, MessageLogger logger) {
        List<RankingExpression> expressions = new ArrayList<>();
        for (Map.Entry<String, SignatureDef> signatureEntry : graph.getSignatureDefMap().entrySet()) {
            Map<String, TensorType> inputs = importInputs(signatureEntry.getValue().getInputsMap());
            for (Map.Entry<String, TensorInfo> output : signatureEntry.getValue().getOutputsMap().entrySet()) {
                try {
                    ExpressionNode result = importOutput(output.getValue(),
                                                         inputs,
                                                         graph.getGraphDef(),
                                                         model,
                                                         constants);
                    expressions.add(new RankingExpression(output.getKey(), result));
                }
                catch (IllegalArgumentException e) {
                    logger.log(Level.INFO, "Skipping output '" + output.getValue().getName() + "' of signature '" +
                                           signatureEntry.getValue().getMethodName() +
                                           "': " + Exceptions.toMessageString(e));
                }
            }
        }
        return expressions;
    }

    private Map<String, TensorType> importInputs(Map<String, TensorInfo> inputInfoMap) {
        Map<String, TensorType> inputs = new HashMap<>();
        inputInfoMap.forEach((key, value) -> inputs.put(nameOf(value.getName()),
                                                        importTensorType(value.getTensorShape())));
        return inputs;
    }

    private TensorType importTensorType(TensorShapeProto tensorShape) {
        TensorType.Builder b = new TensorType.Builder();
        for (int i = 0; i < tensorShape.getDimCount(); i++) {
            int dimensionSize = (int) tensorShape.getDim(i).getSize();
            if (dimensionSize >= 0)
                b.indexed("d" + i, dimensionSize);
            else
                b.indexed("d" + i); // unbound size
        }
        return b.build();
    }

    private ExpressionNode importOutput(TensorInfo output, Map<String, TensorType> inputs, GraphDef graph,
                                        SavedModelBundle model, List<NamedTensor> constants) {
        NodeDef node = getNode(nameOf(output.getName()), graph);
        TensorFunction function = importNode(node, inputs, graph, model, constants).function();
        return new TensorFunctionNode(function); // wrap top level (only) as an expression
    }

    /** Recursively convert a graph of TensorFlow nodes into a Vespa tensor function expression tree */
    private TypedTensorFunction importNode(NodeDef tfNode, Map<String, TensorType> inputs, GraphDef graph,
                                           SavedModelBundle model, List<NamedTensor> constants) {
        return tensorFunctionOf(tfNode, inputs, graph, model, constants);
    }

    private TypedTensorFunction tensorFunctionOf(NodeDef tfNode,
                                                 Map<String, TensorType> inputs,
                                                 GraphDef graph,
                                                 SavedModelBundle model,
                                                 List<NamedTensor> constants) {
        // Import arguments lazily below, as some nodes have arguments unused arguments leading to unsupported ops
        // TODO: Implement mapping of more functions from https://www.tensorflow.org/api_docs/python/
        switch (tfNode.getOp().toLowerCase()) {
            case "add" : case "add_n" : return operationMapper.join(importArguments(tfNode, inputs, graph, model, constants), ScalarFunctions.add());
            case "acos" : return operationMapper.map(importArguments(tfNode, inputs, graph, model, constants), ScalarFunctions.acos());
            case "identity" : return operationMapper.identity(tfNode, inputs, model, constants);
            case "matmul" : return operationMapper.matmul(importArguments(tfNode, inputs, graph, model, constants));
            case "softmax" : return operationMapper.softmax(importArguments(tfNode, inputs, graph, model, constants));
            default : throw new IllegalArgumentException("Conversion of TensorFlow operation '" + tfNode.getOp() + "' is not supported");
        }
    }

    private List<TypedTensorFunction> importArguments(NodeDef tfNode,
                                                      Map<String, TensorType> inputs,
                                                      GraphDef graph,
                                                      SavedModelBundle model,
                                                      List<NamedTensor> constants) {
        return tfNode.getInputList().stream()
                                    .map(argNode -> importNode(getNode(nameOf(argNode), graph), inputs, graph, model, constants))
                                    .collect(Collectors.toList());
    }

    private NodeDef getNode(String name, GraphDef graph) {
        return graph.getNodeList().stream()
                                  .filter(node -> node.getName().equals(name))
                                  .findFirst()
                                  .orElseThrow(() -> new IllegalArgumentException("Could not find node '" + name + "'"));
    }

    /**
     * A method signature input and output has the form name:index.
     * This returns the name part without the index.
     */
    private String nameOf(String name) {
        return name.split(":")[0];
    }

    /** An interface which can be implemented to receive messages emitted during import */
    public interface MessageLogger {

        void log(Level level, String message);

    }

}
